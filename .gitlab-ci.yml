variables:
  VERSION_PATH: "api/api/build-version/"
  DOCKER_BUILDKIT: 1
  MAX_DB_RETRIES: 5

.docker:
  image: $CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX/docker:latest
  interruptible: true
  variables:
    DOCKER_CLI_EXPERIMENTAL: enabled
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  services:
    - name: $CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX/docker:stable-dind
      alias: docker
  before_script:
    - docker info || unset DOCKER_HOST && docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY

.test:
  stage: Testing
  image: $CI_RUNNER
  interruptible: true
  before_script:
    - cd backend
  only:
    - master
    - merge_requests
  needs:
    - Build base runner

.deploy-aws:
  image: $CI_RUNNER
  stage: Deploy
  script:
    - export BUILD_VERSION=$CI_PIPELINE_ID
    - python3 backend/manage.py collectstatic
    - aws s3 sync backend/static s3://${STATIC_BUCKET_NAME}/static --delete --acl public-read > /tmp/s3.log &
    - echo Using - ${DJANGO_SETTINGS_MODULE:=conf.settings_aws}
    - cat taskdef.template.json | envsubst > taskdef.json
    - export TASK_DEFINITION=$(aws ecs register-task-definition --cli-input-json file://taskdef.json | jq -r ".taskDefinition.taskDefinitionArn")
    - cat appspec.template.yaml | envsubst > appspec.yaml
    - aws deploy create-deployment --application-name $APPLICATION_NAME --deployment-group-name $DEPLOYMENT_GROUP --revision revisionType=AppSpecContent,appSpecContent={content="$(cat appspec.yaml)"}
    - wait && cat /tmp/s3.log
    - if ${CI_KUBERNETES_ACTIVE:=false}; then ./bin/check_if_deployed.sh; fi
  dependencies:
    - Build base runner
  only:
    refs:
      - master
    variables:
      - $AWS_ECR

stages:
  - Requirements check
  - Building
  - Testing
  - Build review app
  - Quality assurance
  - Deploy

Build base app:
  stage: Requirements check
  extends: .docker
  script:
    - export IMAGE=$CI_REGISTRY_IMAGE/base:$(md5sum backend/requirements.txt | awk '{print $1}')$(md5sum backend/production.Dockerfile | awk '{print $1}')
    - echo $IMAGE
    - docker manifest inspect $IMAGE || export REBUILD=true
    - if ${REBUILD:=false}; then docker build --tag $IMAGE --no-cache --target=base --file backend/production.Dockerfile backend/; fi
    - if ${REBUILD:=false}; then docker push $IMAGE; fi
    - echo "CI_APP=$IMAGE" >> app.env
  artifacts:
    reports:
      dotenv: app.env
  only:
    - master
    - merge_requests

Build base runner:
  stage: Requirements check
  extends: .docker
  script:
    - export IMAGE=$CI_REGISTRY_IMAGE/runner:$(md5sum backend/requirements.dev.txt | awk '{print $1}')$(md5sum backend/Dockerfile | awk '{print $1}')
    - echo $IMAGE
    - docker manifest inspect $IMAGE || export REBUILD=true
    - if ${REBUILD:=false}; then docker build --tag $IMAGE --no-cache --file backend/Dockerfile backend/; fi
    - if ${REBUILD:=false}; then docker push $IMAGE; fi
    - echo "CI_RUNNER=$IMAGE" >> runner.env
  artifacts:
    reports:
      dotenv: runner.env
  only:
    - master
    - merge_requests

Dependabot Standalone:
  stage: Requirements check
  image:
    name: docker.io/andrcuns/dependabot-gitlab:latest
    entrypoint: [""]
  variables:
    RAILS_ENV: production
    SETTINGS__STANDALONE: "true"
    SETTINGS__GITLAB_URL: https://gitlab.com
  before_script:
    - cd /home/dependabot
  script:
    - bundle exec rake "dependabot:update[$CI_PROJECT_PATH,pip,/backend/]"
  only:
    refs:
      - schedules
      - master
    variables:
      - $SETTINGS__GITLAB_ACCESS_TOKEN
  when: manual

Tag stable runner:
  stage: Building
  extends: .docker
  script:
    - export RUNNER_MANIFEST=$(docker manifest inspect $CI_RUNNER)
    - export STABLE_RUNNER_MANIFEST=$(docker manifest inspect $CI_REGISTRY_IMAGE/runner:stable) || export STABLE_RUNNER_MANIFEST=""
    - >
      if [[ "$RUNNER_MANIFEST" != "$STABLE_RUNNER_MANIFEST" ]]; then
        docker pull $CI_RUNNER;
        docker tag $CI_RUNNER $CI_REGISTRY_IMAGE/runner:stable;
        docker push $CI_REGISTRY_IMAGE/runner:stable;
      fi
  only:
    - master
  needs:
    - Build base runner

Build image:
  stage: Building
  extends: .docker
  image: $CI_RUNNER
  script:
    - if ${AWS_ECR:=false}; then aws ecr get-login-password --region eu-central-1 | docker login --username AWS --password-stdin $AWS_ECR ; fi
    - docker build --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA --file backend/production.Dockerfile --no-cache --build-arg IMAGE=$CI_APP backend/
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - if ${AWS_ECR:=false}; then docker push $AWS_ECR:$CI_COMMIT_SHORT_SHA ; fi
  only:
    - master
  needs:
    - Build base runner
    - Build base app

Code quality:
  variables:
    KUBERNETES_CPU_REQUEST: 2750m
    KUBERNETES_CPU_LIMIT: 2750m
  extends: .test
  script:
    - flakehell lint --format=gitlab --output-file flakehell.json || export FAIL=true
    - cat flakehell.json | sed 's/.\/apps/backend\/apps/g' > codeclimate.json
    - if ${FAIL:=false}; then false; fi
  artifacts:
    reports:
      codequality: backend/codeclimate.json

MyPY:
  extends: .test
  variables:
    KUBERNETES_CPU_REQUEST: 700m
    KUBERNETES_CPU_LIMIT: 700m
  script:
    - mypy apps --config-file mypy.ini --junit-xml mypy.xml
  artifacts:
    reports:
      junit: backend/mypy.xml

Dependency scanning:
  extends: .test
  variables:
    KUBERNETES_CPU_REQUEST: 1000m
    KUBERNETES_CPU_LIMIT: 1000m
  script:
    - safety check -r requirements.txt --full-report || export FAIL=true
    - safety check -r requirements.dev.txt --full-report || export FAIL=true
    - if ${FAIL:=false}; then false; fi
  only:
    - merge_requests

Tests:
  extends: .test
  services:
    - name: $CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX/postgres:latest
      alias: postgres
    - name: $CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX/redis:latest
      alias: redis
  variables:
    KUBERNETES_CPU_REQUEST: 3000m
    KUBERNETES_CPU_LIMIT: 3000m
    DB_HOST: postgres
    DB_USER: postgres
    POSTGRES_PASSWORD: django
    POSTGRES_DB: django
    DB_PORT: 5432
  coverage: '/Total coverage: (\d+.\d+)%/'
  before_script:
    - cd backend
    - while ! pg_isready -h $DB_HOST -U $DB_USER -d $POSTGRES_DB -q && [[ ${RETRY:=0} -lt MAX_DB_RETRIES ]]; do sleep 5 && RETRY=$((RETRY + 1)); done
  script:
    - python3 -m pytest apps --cov --cov-report=term --cov-report=xml:cov.xml --junitxml=pytest.xml || export FAIL=true
    - cat cov.xml | sed 's/apps/backend\/apps/g' > coverage.xml
    - if ${FAIL:=false}; then false; fi
  artifacts:
    reports:
      cobertura: backend/coverage.xml
      junit: backend/pytest.xml
  only:
    - merge_requests

Test fixtures:
  variables:
    KUBERNETES_CPU_REQUEST: 700m
    KUBERNETES_CPU_LIMIT: 700m
  extends: Tests
  script:
    - python3 manage.py migrate
    - python3 manage.py loaddata initial.json

Test build:
  extends: Tests
  image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  before_script:
    - cd /app
  after_script:
    - mv /app/*.xml backend/
  only:
    - master
  needs:
    - Build image

Build review app image:
  stage: Build review app
  extends: .docker
  image: $CI_RUNNER
  script:
    - docker build --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA --file backend/production.Dockerfile --no-cache --build-arg IMAGE=$CI_APP backend/
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  only:
    kubernetes: active
    refs:
      - merge_requests
  needs:
    - Build base runner
    - Build base app

Deploy review app:
  stage: Quality assurance
  image: $CI_RUNNER
  environment:
    name: Review app MR$CI_MERGE_REQUEST_IID
    url: https://$CI_ENVIRONMENT_SLUG.$KUBE_INGRESS_BASE_DOMAIN/admin/
    on_stop: Teardown review app
    auto_stop_in: 1 day
  before_script:
    - kubectl delete secret regcred || true
    - CI_ENVIRONMENT_URL=${CI_ENVIRONMENT_URL:8:-7}
  script:
    - kubectl version
    - if $(kubectl get secret regcred); then kubectl delete secret regcred; fi
    - kubectl create secret docker-registry regcred --docker-server=$CI_REGISTRY --docker-username=$CI_REGISTRY_USER --docker-password=$CI_REGISTRY_PASSWORD
    - cat review-app-values.template.yaml | envsubst | kubectl apply -f -
    - kubectl set image deployment.v1.apps/$CI_ENVIRONMENT_SLUG application=${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} --record || cat manifest.template.yaml | envsubst | kubectl apply -f -
    - kubectl rollout status deployment.v1.apps/$CI_ENVIRONMENT_SLUG || export ROLLBACK=true
    - kubectl logs $(kubectl get pods | grep $CI_ENVIRONMENT_SLUG | tail -n 1 | awk '{print $1}') -c application
    - if ${ROLLBACK:=false}; then kubectl rollout undo deployment.v1.apps/$CI_ENVIRONMENT_SLUG && false; fi
  after_script:
    - kubectl delete secret regcred
  when: manual
  only:
    kubernetes: active
    refs:
      - merge_requests
  needs:
    - Tests
    - Code quality
    - MyPY
    - Build review app image
    - Build base runner
    - Test fixtures

Teardown review app:
  stage: Quality assurance
  image: $CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX/dtzar/helm-kubectl:3.3.4
  script:
    - kubectl delete deployments --all
    - kubectl delete services --all
    - kubectl delete ingress --all
    - kubectl delete pvc --all
  when: manual
  only:
    kubernetes: active
    refs:
      - merge_requests
  environment:
    name: Review app MR$CI_MERGE_REQUEST_IID
    action: stop

Deploy development:
  extends: .deploy-aws
  environment: Development

Deploy production:
  extends: Deploy development
  environment: Production
  when: manual
