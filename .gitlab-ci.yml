variables:
  VERSION_PATH: "api/api/build-version/"
  DOCKER_BUILDKIT: 1
  MAX_DB_RETRIES: 5

.docker:
  image: $CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX/docker:latest
  interruptible: true
  variables:
    DOCKER_CLI_EXPERIMENTAL: enabled
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  services:
    - name: $CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX/docker:stable-dind
      alias: docker
  before_script:
    - docker info || unset DOCKER_HOST && docker info
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY

.test:
  stage: Testing
  image: $CI_RUNNER
  interruptible: true
  only:
    - master
    - merge_requests
    - /^hotfix.*$/
  needs:
    - Build base runner

.deploy:
  image: $CI_RUNNER
  variables:
    KUBERNETES_CPU_REQUEST: 500m
    KUBERNETES_CPU_LIMIT: 500m
  before_script:
    - kubectl delete secret regcred || true
    - CI_ENVIRONMENT_URL=${CI_ENVIRONMENT_URL:8:-7}
  script:
    - kubectl version
    - if $(kubectl get secret regcred); then kubectl delete secret regcred; fi
    - kubectl create secret docker-registry regcred --docker-server=$CI_REGISTRY --docker-username=$CI_REGISTRY_USER --docker-password=$CI_REGISTRY_PASSWORD
    - cat review-app-values.template.yaml | envsubst | kubectl apply -f -
    - kubectl set image deployment.v1.apps/$CI_ENVIRONMENT_SLUG application=${CI_REGISTRY_IMAGE}:${CI_COMMIT_SHORT_SHA} || cat manifest.template.yaml | envsubst | kubectl apply -f -
    - kubectl rollout status deployment.v1.apps/$CI_ENVIRONMENT_SLUG || export ROLLBACK=true
    - kubectl logs $(kubectl get pods | grep $CI_ENVIRONMENT_SLUG | tail -n 1 | awk '{print $1}') -c application
    - if ${ROLLBACK:=false}; then kubectl rollout undo deployment.v1.apps/$CI_ENVIRONMENT_SLUG && false; fi
  after_script:
    - kubectl delete secret regcred

stages:
  - Requirements check
  - Testing
  - Security testing
  - Quality assurance
  - Prepare release
  - Deploy
  - Utility

Build base app:
  stage: Requirements check
  extends: .docker
  script:
    - export IMAGE=$CI_REGISTRY_IMAGE/base:$(md5sum requirements/requirements.txt | awk '{print $1}')$(md5sum production.Dockerfile | awk '{print $1}')
    - echo $IMAGE
    - docker manifest inspect $IMAGE || export REBUILD=true
    - if ${REBUILD:=false}; then docker build --tag $IMAGE --no-cache --target=base --file production.Dockerfile .; fi
    - if ${REBUILD:=false}; then docker push $IMAGE; fi
    - echo "CI_APP=$IMAGE" >> app.env
  artifacts:
    reports:
      dotenv: app.env
  only:
    - master
    - merge_requests
    - /^hotfix.*$/

Build base runner:
  stage: Requirements check
  extends: .docker
  script:
    - export IMAGE=$CI_REGISTRY_IMAGE/runner:$(md5sum requirements/requirements.dev.txt | awk '{print $1}')$(md5sum Dockerfile | awk '{print $1}')
    - echo $IMAGE
    - docker manifest inspect $IMAGE || export REBUILD=true
    - if ${REBUILD:=false}; then docker build --tag $IMAGE --no-cache .; fi
    - if ${REBUILD:=false}; then docker push $IMAGE; fi
    - echo "CI_RUNNER=$IMAGE" >> runner.env
  artifacts:
    reports:
      dotenv: runner.env
  only:
    - master
    - merge_requests
    - /^hotfix.*$/

Build gitpod runner:
  stage: Requirements check
  extends: .docker
  script:
    - export IMAGE=$CI_REGISTRY_IMAGE/gitpod:$(md5sum requirements/requirements.dev.txt | awk '{print $1}')$(md5sum gitpod.Dockerfile | awk '{print $1}')
    - echo $IMAGE
    - docker manifest inspect $IMAGE || export REBUILD=true
    - if ${REBUILD:=false}; then docker build --tag $IMAGE --no-cache --file gitpod.Dockerfile .; fi
    - if ${REBUILD:=false}; then docker push $IMAGE; fi
    - echo "CI_GITPOD_RUNNER=$IMAGE" >> runner.env
  artifacts:
    reports:
      dotenv: runner.env
  only:
    - master

Dependabot Standalone:
  stage: Requirements check
  image:
    name: $CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX/andrcuns/dependabot-gitlab:0.3.10
    entrypoint: [""]
  variables:
    RAILS_ENV: production
    SETTINGS__STANDALONE: "true"
    SETTINGS__GITLAB_URL: https://gitlab.com
  before_script:
    - cd /home/dependabot/app
  script:
    - bundle exec rake "dependabot:update[$CI_PROJECT_PATH,pip,/]"
  only:
    refs:
      - master
      - /^hotfix.*$/
    variables:
      - $SETTINGS__GITLAB_ACCESS_TOKEN
  when: manual

Dependabot Standalone Scheduled:
  extends: Dependabot Standalone
  when: on_success
  only:
    refs:
      - schedules
    variables:
      - $SETTINGS__GITLAB_ACCESS_TOKEN

Tag stable gitpod runner:
  stage: Requirements check
  extends: .docker
  script:
    - export RUNNER_MANIFEST=$(docker manifest inspect $CI_GITPOD_RUNNER)
    - export STABLE_RUNNER_MANIFEST=$(docker manifest inspect $CI_REGISTRY_IMAGE/gitpod:stable) || export STABLE_RUNNER_MANIFEST=""
    - >
      if [[ "$RUNNER_MANIFEST" != "$STABLE_RUNNER_MANIFEST" ]]; then
        docker pull $CI_GITPOD_RUNNER;
        docker tag $CI_GITPOD_RUNNER $CI_REGISTRY_IMAGE/gitpod:stable;
        docker push $CI_REGISTRY_IMAGE/gitpod:stable;
      fi
  only:
    - master
    - /^hotfix.*$/
  needs:
    - Build gitpod runner

Build app image:
  stage: Requirements check
  extends: .docker
  image: $CI_RUNNER
  script:
    - docker build --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA --file production.Dockerfile --no-cache --build-arg IMAGE=$CI_APP .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  only:
    - master
    - merge_requests
    - /^hotfix.*$/
  needs:
    - Build base runner
    - Build base app

Container scanning:
  stage: Security testing
  image:
    name: $CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX/aquasec/trivy:latest
    entrypoint: [""]
  allow_failure: true
  variables:
    GIT_STRATEGY: none
    TRIVY_USERNAME: $CI_REGISTRY_USER
    TRIVY_PASSWORD: $CI_REGISTRY_PASSWORD
    TRIVY_AUTH_URL: $CI_REGISTRY
  script:
    - trivy image --no-progress --format template --template "@/contrib/html.tpl" -o report.html $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  only:
    - merge_requests
    - master
    - /^hotfix.*$/
  needs:
    - Build app image
  artifacts:
    paths:
      - report.html

Code quality:
  variables:
    KUBERNETES_CPU_REQUEST: 2750m
    KUBERNETES_CPU_LIMIT: 2750m
  extends: .test
  script:
    - pflake8 --format gl-codeclimate --output-file codeclimate.json apps
  artifacts:
    reports:
      codequality: codeclimate.json

MyPY:
  extends: .test
  variables:
    KUBERNETES_CPU_REQUEST: 700m
    KUBERNETES_CPU_LIMIT: 700m
  script:
    - mypy apps --config-file mypy.ini --junit-xml mypy.xml
  artifacts:
    reports:
      junit: backend/mypy.xml

Dependency scanning:
  stage: Security testing
  extends: .test
  allow_failure: true
  variables:
    KUBERNETES_CPU_REQUEST: 1000m
    KUBERNETES_CPU_LIMIT: 1000m
  script:
    - safety check -r requirements/requirements.txt --full-report || export FAIL=true
    - safety check -r requirements/requirements.dev.txt --full-report || export FAIL=true
    - if ${FAIL:=false}; then exit 1; fi
  only:
    - merge_requests

Tests:
  extends: .test
  services:
    - name: $CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX/postgis/postgis:latest
      alias: postgres
    - name: $CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX/redis:latest
      alias: redis
  variables:
    KUBERNETES_CPU_REQUEST: 3000m
    KUBERNETES_CPU_LIMIT: 3000m
    DB_HOST: postgres
    DB_USER: postgres
    POSTGRES_PASSWORD: django
    POSTGRES_DB: django
    DB_PORT: 5432
  coverage: '/Total coverage: (\d+.\d+)%/'
  before_script:
    - while ! pg_isready -h $DB_HOST -U $DB_USER -d $POSTGRES_DB -q && [[ ${RETRY:=0} -lt MAX_DB_RETRIES ]]; do sleep 5 && RETRY=$((RETRY + 1)); done
  script:
    - python3 -m pytest apps --cov --cov-report=term --cov-report=xml:cov.xml --junitxml=pytest.xml || export FAIL=true
  artifacts:
    reports:
      cobertura: coverage.xml
      junit: pytest.xml
  only:
    - merge_requests

Test fixtures:
  variables:
    KUBERNETES_CPU_REQUEST: 700m
    KUBERNETES_CPU_LIMIT: 700m
  extends: Tests
  script:
    - python3 manage.py migrate
    - python3 manage.py loaddata initial.json

Check migrations:
  variables:
    KUBERNETES_CPU_REQUEST: 700m
    KUBERNETES_CPU_LIMIT: 700m
  extends: Tests
  script:
    - python3 manage.py makemigrations --check --noinput
  only:
    - master
    - merge_requests
    - /^hotfix.*$/

Test build:
  extends: Tests
  image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
  before_script:
    - cd /app
  after_script:
    - mv /app/*.xml .
  only:
    - master
    - /^hotfix.*$/
  needs:
    - Build app image

Deploy review app:
  extends: .deploy
  stage: Quality assurance
  environment:
    name: Review app MR$CI_MERGE_REQUEST_IID
    url: https://$CI_ENVIRONMENT_SLUG.$KUBE_INGRESS_BASE_DOMAIN/admin/
    on_stop: Teardown review app
    auto_stop_in: 1 day
  when: manual
  only:
    kubernetes: active
    refs:
      - merge_requests
  needs:
    - Tests
    - Code quality
    - MyPY
    - Build app image
    - Build base runner
    - Test fixtures
    - Check migrations

Teardown review app:
  stage: Quality assurance
  image: $CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX/dtzar/helm-kubectl:3.3.4
  script:
    - kubectl delete deployments --all
    - kubectl delete services --all
    - kubectl delete ingress --all
    - kubectl delete pvc --all
  when: manual
  only:
    kubernetes: active
    refs:
      - merge_requests
  environment:
    name: Review app MR$CI_MERGE_REQUEST_IID
    action: stop

ZAP AJAX admin scan:
  image: registry.gitlab.com/gitlab-org/security-products/analyzers/dast:latest
  stage: Quality assurance
  variables:
    KUBERNETES_CPU_REQUEST: 3000m
    KUBERNETES_CPU_LIMIT: 3000m
    DAST_AUTH_URL: ${CI_ENVIRONMENT_URL}login/
    DAST_USERNAME: test@test.com
    DAST_PASSWORD: test
    DAST_BROWSER_SCAN: 'true'
    DAST_WEBSITE: $CI_ENVIRONMENT_URL
    DAST_FULL_SCAN_ENABLED: 1
    DAST_INCLUDE_ALPHA_VULNERABILITIES: 1
    GITLAB_FEATURES: dast
    DAST_BROWSER_NUMBER_OF_BROWSERS: 8
  environment:
    name: Review app MR$CI_MERGE_REQUEST_IID
    action: prepare
  script:
    - export DAST_USERNAME_FIELD=id:id_username
    - export DAST_PASSWORD_FIELD=id:id_password
    - /analyze -r report.html
  only:
    kubernetes: active
    refs:
      - merge_requests
  when: manual
  artifacts:
    paths:
      - report.html
  needs:
    - Deploy review app

ZAP API scan:
  image: registry.gitlab.com/gitlab-org/security-products/analyzers/dast:latest
  stage: Quality assurance
  variables:
    DAST_API_PROFILE: Full
    DAST_INCLUDE_ALPHA_VULNERABILITIES: 1
    GITLAB_FEATURES: dast
  environment:
    name: Review app MR$CI_MERGE_REQUEST_IID
    action: prepare
  script:
    - source ./bin/dast.sh
    - export DAST_API_TARGET_URL=${CI_ENVIRONMENT_URL::-6}
    - export DAST_API_OPENAPI=${CI_ENVIRONMENT_URL::-7}/schema/?format=yaml
    - /analyze -r report.html
  only:
    kubernetes: active
    refs:
      - merge_requests
  when: manual
  artifacts:
    paths:
      - report.html
  needs:
    - Deploy review app

Collect schema changes:
  image: $CI_RUNNER
  environment:
    name: Development
    action: prepare
  stage: Prepare release
  variables:
    DOCKER_CLI_EXPERIMENTAL: enabled
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  services:
    - name: $CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX/docker:stable-dind
      alias: docker
  before_script:
    - docker info || unset DOCKER_HOST && docker info
    - echo "$CI_DEPENDENCY_PROXY_PASSWORD" | docker login -u $CI_DEPENDENCY_PROXY_USER --password-stdin $CI_DEPENDENCY_PROXY_SERVER
  script:
    - python manage.py spectacular > /tmp/schema_new.yaml
    - kubectl exec -t deployment.v1.apps/$CI_ENVIRONMENT_SLUG -c application -- python3 manage.py spectacular > /tmp/schema_old.yaml
    - export OPENAPI_DIFF=$(docker create --rm -t openapitools/openapi-diff:latest schema_old.yaml schema_new.yaml)
    - docker cp /tmp/schema_new.yaml $OPENAPI_DIFF:/app/schema_new.yaml
    - docker cp /tmp/schema_old.yaml $OPENAPI_DIFF:/app/schema_old.yaml
    - docker start -a $OPENAPI_DIFF > CHANGELOG.md
    - if [[ -n "$SENTRY_PROJECT_NAME" ]]; then sentry-cli releases --project $SENTRY_PROJECT_NAME new $CI_COMMIT_SHORT_SHA; fi
    - if [[ -n "$SENTRY_PROJECT_NAME" ]]; then sentry-cli releases set-commits --auto $CI_COMMIT_SHORT_SHA; fi
  artifacts:
    paths:
      - CHANGELOG.md
  only:
    kubernetes: active
    refs:
      - master
      - /^hotfix.*$/
  needs:
    - Build base runner

Create release:
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  stage: Prepare release
  script:
    - if $(grep -q 'No differences. Specifications are equivalents' CHANGELOG.md); then exit 1; fi
  release:
    tag_name: $CI_COMMIT_SHORT_SHA
    description: CHANGELOG.md
  allow_failure: True
  needs:
    - Collect schema changes
  only:
    kubernetes: active
    refs:
      - master
      - /^hotfix.*$/

Deploy development environment:
  extends: .deploy
  stage: Deploy
  environment:
    name: Development
  only:
    kubernetes: active
    refs:
      - master
  needs:
    - Test build
    - Code quality
    - MyPY
    - Build app image
    - Build base runner
    - Check migrations

Dump development database:
  image: $CI_RUNNER
  environment:
    name: Development
    action: prepare
  stage: Utility
  script:
    - kubectl exec deployment.v1.apps/$CI_ENVIRONMENT_SLUG -c application -- bash -c "pg_dump -h \$DB_HOST -U \$DB_USER \$DB_NAME" > database.sql
  artifacts:
    paths:
      - database.sql
  when: manual
  only:
    kubernetes: active
    refs:
      - master
      - merge_requests
  needs:
    - Build base runner

Load development database:
  stage: Utility
  image: $CI_RUNNER
  environment:
    name: Review app MR$CI_MERGE_REQUEST_IID
    action: prepare
  script:
    - cat database.sql | kubectl exec -i deployment.v1.apps/$CI_ENVIRONMENT_SLUG -c application -- bash -c "psql -h \$DB_HOST -U \$DB_USER -d \$DB_NAME"
  only:
    kubernetes: active
    refs:
      - merge_requests
  needs:
    - Build base runner
    - Dump development database
    - Deploy review app
